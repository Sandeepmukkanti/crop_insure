import { useState, useEffect } from 'react';
import { useWallet } from '@aptos-labs/wallet-adapter-react';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '../components/ui/card';
import { Button } from '../components/ui/button';
import { Input } from '../components/ui/input';
import { Label } from '../components/ui/label';
import { useToast } from '../components/ui/use-toast';
import { CropInsuranceService } from '../services/crop-insurance';
import { CROP_TYPES } from '../constants';
import type { PolicyTemplate, CreatePolicyTemplateParams, Claim, Policy } from '../types/crop-insurance';
import { 
  Shield, 
  Plus, 
  Settings,
  FileText,
  AlertTriangle,
  Loader2,
  Edit,
  Trash2,
  Eye,
  CheckCircle
} from 'lucide-react';

export default function AdminDashboardPage() {
  const { connected, account, signAndSubmitTransaction, wallet } = useWallet();
  const { toast } = useToast();
  const [activeTab, setActiveTab] = useState<'create' | 'manage' | 'claims'>('create');
  const [policyTemplates, setPolicyTemplates] = useState<PolicyTemplate[]>([]);
  const [claims, setClaims] = useState<Claim[]>([]);
  const [policies, setPolicies] = useState<Policy[]>([]);
  const [loading, setLoading] = useState(false);
  const [creatingTemplate, setCreatingTemplate] = useState(false);

  const [templateForm, setTemplateForm] = useState<CreatePolicyTemplateParams>({
    name: '',
    crop_type: '',
    coverage_amount: 0,
    premium: 0,
    duration_days: 30
  });

  const isAdmin = account ? CropInsuranceService.isAdmin(account.address.toString()) : false;

  // Debug wallet connection
  useEffect(() => {
    console.log('Wallet Debug Info:', {
      connected,
      account: account?.address?.toString(),
      walletName: wallet?.name,
      isAdmin,
    });
  }, [connected, account, wallet, isAdmin]);

  const handleApproveClaim = async (claimId: string, policy: Policy) => {
    if (!connected || !account || !signAndSubmitTransaction) {
      toast({
        title: "Wallet Not Connected",
        description: "Please connect your wallet first.",
        variant: "destructive",
      });
      return;
    }

    // Find the existing claim
    const existingClaim = claims.find(c => c.id === claimId);
    if (!existingClaim) {
      toast({
        title: "Error",
        description: "Claim not found",
        variant: "destructive",
      });
      return;
    }

    // Check if claim is already processed
    if (existingClaim.status === 2 || existingClaim.status === 3) {
      toast({
        title: "Claim Already Processed",
        description: `This claim has already been ${existingClaim.status === 2 ? 'approved' : 'rejected'}.`,
        variant: "destructive",
      });
      return;
    }

    if (!window.confirm("Are you sure you want to approve this claim? The coverage amount will be transferred to the farmer.")) {
      return;
    }

    try {
      setLoading(true);
      
      // Try blockchain first
      try {
        const transactionPayload = CropInsuranceService.approveClaimTransaction(claimId);
        
        const response = await signAndSubmitTransaction({
          sender: account.address,
          data: {
            function: transactionPayload.function as `${string}::${string}::${string}`,
            functionArguments: transactionPayload.functionArguments,
          },
          options: {
            maxGasAmount: 5000,
            gasUnitPrice: 100,
          },
        });

        // Update UI state
        const updatedClaim = {
          ...existingClaim,
          status: 2, // 2 = CLAIM_APPROVED
          processed_at: Math.floor(Date.now() / 1000).toString()
        };

        setClaims(prevClaims => 
          prevClaims.map(c => c.id === claimId ? updatedClaim : c)
        );

        // Update localStorage
        const approvedClaim = {
          id: claimId,
          status: 'approved',
          approvedAt: Date.now(),
          approvedBy: account.address.toString(),
          amountPaid: policy.coverage_amount,
          farmerAddress: existingClaim.farmer,
          transactionHash: response.hash
        };

        const approvedClaims = JSON.parse(localStorage.getItem('approvedClaims') || '[]');
        approvedClaims.push(approvedClaim);
        localStorage.setItem('approvedClaims', JSON.stringify(approvedClaims));

        // Update allClaims in localStorage
        const allClaims = JSON.parse(localStorage.getItem('allClaims') || '[]');
        const updatedAllClaims = allClaims.map((c: any) => 
          c.id === claimId ? updatedClaim : c
        );
        localStorage.setItem('allClaims', JSON.stringify(updatedAllClaims));

        toast({
          title: "Claim Approved Successfully! ðŸŽ‰",
          description: `Transaction: ${response.hash.slice(0, 10)}... Farmer will receive ${CropInsuranceService.octasToApt(parseInt(policy.coverage_amount)).toFixed(2)} APT`,
        });

      } catch (blockchainError) {
        console.error('Blockchain approval failed, using localStorage with APT transfer simulation:', blockchainError);
        
        // Fallback to localStorage - UPDATE EXISTING CLAIM STATUS
        const allClaims = JSON.parse(localStorage.getItem('allClaims') || '[]');
        const updatedClaims = allClaims.map((claim: any) => 
          claim.id === claimId 
            ? { ...claim, status: 2, processed_at: Math.floor(Date.now() / 1000).toString() } // 2 = approved
            : claim
        );
        localStorage.setItem('allClaims', JSON.stringify(updatedClaims));
        
        // Find the claim to get farmer address
        const targetClaim = claims.find(c => c.id === claimId);
        if (!targetClaim) {
          throw new Error('Claim not found');
        }

        // Also store in approved claims
        const claimData = {
          id: claimId,
          status: 'approved',
          approvedAt: Date.now(),
          approvedBy: account.address.toString(),
          amountPaid: policy.coverage_amount,
          farmerAddress: targetClaim.farmer
        };
        
        const approvedClaims = JSON.parse(localStorage.getItem('approvedClaims') || '[]');
        approvedClaims.push(claimData);
        localStorage.setItem('approvedClaims', JSON.stringify(approvedClaims));

        // Simulate APT transfer to farmer (in a real scenario, this would be handled by the smart contract)
        console.log(`ðŸ’° Simulating APT transfer: ${CropInsuranceService.octasToApt(parseInt(policy.coverage_amount)).toFixed(2)} APT to farmer ${targetClaim.farmer}`);

        toast({
          title: "Claim Approved Successfully! ðŸŽ‰",
          description: `${CropInsuranceService.octasToApt(parseInt(policy.coverage_amount)).toFixed(2)} APT has been approved for transfer to farmer ${CropInsuranceService.formatAddress(targetClaim.farmer)}`,
        });
      }
      
      // Refresh claims data
      await fetchClaims();
      
    } catch (error: any) {
      console.error('Error approving claim:', error);
      
      let errorTitle = "Approval Failed";
      let errorMessage = "Failed to approve claim. Please try again.";
      
      if (error.message && error.message.includes("User has rejected the request")) {
        errorTitle = "Transaction Cancelled";
        errorMessage = "You cancelled the transaction in your wallet.";
      } else if (error.message) {
        errorMessage = error.message;
      }
      
      toast({
        title: errorTitle,
        description: errorMessage,
        variant: "destructive"
      });
    } finally {
      setLoading(false);
    }
  };

  // ... rest of your component code ...
}
